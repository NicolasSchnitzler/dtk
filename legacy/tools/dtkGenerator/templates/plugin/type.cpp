// /////////////////////////////////////////////////////////////////
// Generated by dtkPluginGenerator
// /////////////////////////////////////////////////////////////////

#include "%1.h"

#include <dtkCore/dtkAbstract%4Factory.h>
#include %2


// /////////////////////////////////////////////////////////////////
// %1Private interface
// /////////////////////////////////////////////////////////////////

// 1-%1
// 2-%2
// 3-%3
// 4-%4
// 5-%5

class %1Private : public %3Private
{
public:
    %1Private(%1 *q = 0) : %3Private(q) {}
    %1Private(const %1Private& other) : %3Private(other) {} // Complete copy ctror with your local members.

public:
    ~%1Private(void) {}

public:
    // private members are put here, eg
    // int index;
};

////////////////////////////////////////////////////
// %1 protected constructors
////////////////////////////////////////////////////

DTK_IMPLEMENT_PRIVATE(%1, %3);

// /////////////////////////////////////////////////////////////////
// %1 implementation
// /////////////////////////////////////////////////////////////////

%1::%1(void) : %3(*new %1Private(this), 0)
{

}

%1::%1(const %1& other) : %3(*new %1Private(*other.d_func()), other)
{

}

%1::~%1(void)
{

}

%1& %1::operator = (const %1& other)
{
    this->copy(other);
    return *this;
}

void %1::copy(const dtkAbstract%4& other)
{
    if (this== &other)
        return;
    %1::copy(other);
    if (other.identifier() == this->identifier() )
       {}
       else
       {
           dtkWarn() << "Copy can't be done at the supAbstractProcessAcquisitor level.";
       }
}


bool %1::registered(void)
{
    return dtkAbstract%4Factory::instance()->register%4Type("%1", create%5, "%3");
}


QString %1::identifier(void) const
{
    return "%1";
}

// /////////////////////////////////////////////////////////////////
// Type instantiation
// /////////////////////////////////////////////////////////////////

dtkAbstract%4 *create%5(void)
{
    return new %1;
}
